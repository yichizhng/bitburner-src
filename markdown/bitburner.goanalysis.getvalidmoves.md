<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [bitburner](./bitburner.md) &gt; [GoAnalysis](./bitburner.goanalysis.md) &gt; [getValidMoves](./bitburner.goanalysis.getvalidmoves.md)

## GoAnalysis.getValidMoves() method

Shows if each point on the board is a valid move for the player. By default, analyzes the current board state. Takes an optional boardState (and an optional prior-move boardState, if desired) to analyze a custom board.

The true/false validity of each move can be retrieved via the X and Y coordinates of the move. `const validMoves = ns.go.analysis.getValidMoves();`

`const moveIsValid = validMoves[x][y];`

Note that the \[0\]\[0\] point is shown on the bottom-left on the visual board (as is traditional), and each string represents a vertical column on the board. In other words, the printed example above can be understood to be rotated 90 degrees clockwise compared to the board UI as shown in the IPvGO subnet tab.

Also note that, when given a custom board state, only one prior move can be analyzed. This means that the superko rules (no duplicate board states in the full game history) is not supported; you will have to implement your own analysis for that.

playAsWhite is optional, and gets the current valid moves for the white player. Intended to be used when playing as white when the opponent is set to "No AI"

**Signature:**

```typescript
getValidMoves(boardState?: string[], priorBoardState?: string[], playAsWhite = false): boolean[][];
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  boardState | string\[\] | _(Optional)_ |
|  priorBoardState | string\[\] | _(Optional)_ |
|  playAsWhite | (not declared) | _(Optional)_ |

**Returns:**

boolean\[\]\[\]

## Remarks

RAM cost: 8 GB (This is intentionally expensive; you can derive this info from just getBoardState() )

